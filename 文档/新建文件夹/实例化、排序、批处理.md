### 实例化、排序、批处理

##### 需要考虑的问题

实例化绘制需要考虑如何组织实例化数据？

1.多个实例化数据是不同实体，但共享rendercomponent

2.逐实体绘制的方法，不能实现实例化

3.将实例化数据放在一个数组中进行管理

应该允许实例化数据常数不同，使用UBO存放各实例化常量，通过实例id索引UBO





##### 实例化数据如何存储

1.SSBO：允许GPU写入，使用GPU driven的实例化绘制

2.顶点数组：适合CPU做剔除和写入实例化数据

3.UBO

所有物体的所有实例数据都统一放在一个大缓冲区中。实例化绘制时，每个物体根据偏移和自身实例化数目索引该缓冲区。

*要分批实例化绘制*



##### 实例化绘制和材质排序

```
// 三级嵌套的map结构：材质 -> 网格 -> 实例列表
std::map<VulkanPBRMaterial*, std::map<VulkanMesh*, std::vector<MeshNode>>> main_camera_mesh_drawcall_batch;


CPU收集渲染数据：
遍历所有可见物体，按材质和网格分组
上传实例化数据(实例化数据必须是上传堆，属于帧资源，需要每帧更新)


绘制：
两层循环依次遍历材质、网格
绘制所有实例

渲染器可见的不是rendercomponent，而是material和vao组合

```









##### 现代引擎的实例化绘制方案

1.间接绘制 (Indirect Drawing)：由计算着色器在GPU端完成剔除，给出可见的实例化绘制列表

2.task shader完成剔除，mesh shader为可见图元生成顶点和图元数据



间接多重绘制：

所有物体的顶点缓冲、实例化缓冲都用一个统一的缓冲区存储，使用间接指令缓冲区存储绘制所需的元数据（顶点偏移和数目等），一次渲染命令提交就可以绘制不同物体，让GPU负责剔除、索引等



##### 实例化绘制性能优化

1.整理所有实体实例化数据（CollectInstanceData函数），需要遍历所有实体。当实体数目巨大，例如100k时，遍历操作本身开销巨大。可能和缓存未命中有关。可以优化

2.循环内部不要进行进行耗时操作，例如矩阵运算、数据拷贝、初始化等。循环要短小？

3.使用剔除，跳过不可见实体

4.使用脏数据标记跳过未更新的数据。直接实体数据通过内存映射上传到GPU，避免中间缓存的开销。



使用gpu-driven，将实例数据的计算交给GPU，既能并行加速，又避免了上传实例数据的开销。在存在大量实例时，尤为有用。





### 问题

为什么要避免多个小缓冲区，而是使用大缓冲区

