C++

### 基础知识

* 非成员函数声明为静态时，其作用域限制为当前编译单元
* C++不同类型指针不允许任意转化，但都可以转化为void * ； void * 只表示地址，消除了类型。底层API、C函数等可能用到void* 
* reinterpret_cast<>用于强制转化无关的类型。使用结构体就会有潜在的对齐问题，在强制类型转化时候要小心
* 一个接口类般不建议有非静态成员变量，因为接口类通常用于实现多态的，没有必要存储状态



计时器：
```
#include <windows.h>


```





### 性能优化

函数返回值类型会有临时对象，即使编译器有ROV优化，也会在返回处栈上构造临时对象。能返回引用类型就不要返回值类型。



### 其它

##### 命名规范

类成员变量和函数

普通变量和函数

常量和宏

类名、结构体名、命名空间名

https://chat.deepseek.com/share/lz3j4g4zofgm89p5fn





### “八股”

##### **虚函数相关**

* RTTI：运行时识别对象的实际类型，为了多态服务。RTTI和虚函数都依赖编译器在类结构中插入的隐藏信息实现。当存在虚函数时，生成虚表指针和虚表，并在虚表中插入type_info指针，用于支持type_id和dynamic_cast。

* 虚函数和RTTI：RTTI开销更大，能用虚函数直接用虚函数，除非一定需要访问子类非虚的成员

* 动态绑定：C++的指针或引用是动态类型，即运行时才能确定实际类型。而其它均是静态类型。

注意：即便存在继承关系，**无虚函数时**，就无虚函数/虚表，**RTTI也不能使用**

问题：无虚函数的类的指针/引用也是动态类型吗？这时候没有RTTI





##### 内存布局相关

类的内存布局：虚表指针、父类成员、自己的成员。注意**内存对齐**

访问成员如何寻址：编译器在编译期就知道了每个成员的偏移了，偏移会写入汇编中



**C++内存对齐规则：**
类/结构体大小必须是**最大成员的整数倍**，保证最大成员对齐。不足的需要填充

**std140对齐**



* 指针，例如虚表指针在64位程序上是**8字节**，int在不同平台保证4字节，而unsigned int有平台差异 
* 虚表指针放在类的开头，是因为不需运行时偏移就能找到虚表指针，vptr 在前，不是为了省偏移“加法”，而是为了布局统一和 **cache 友好**（如果跨cache line会很慢）



**程序内存布局**：

程序镜像注意区分：BSS段，即未初始化的全局变量（加载到内存中会默认初始化为0）；显式初始化的全局变量加载到.data区

地址从高到低：栈、堆、.bss（未显式初始化的全局/静态变量）、.data（全局/静态变量）、.rodata（const全局变量、字符串字面量）、.text（代码段）

注意：

* const的局部变量存放在栈中，而**const全局变量**在只读数据段
* 局部的静态变量、类的静态成员变量、全局静态成员变量都是存在在全局/静态区。生命周期都是程序周期，但局部静态变量是懒加载的，执行到定义语义是才分配内存和初始化



* BSS段加载到内存中默认初始化为0

* 类的静态成员必须显式初始化。类的静态成员是共享的，因此类的构造函数不为其分配地址，必须在类外定义（定义才能分配内存地址）

* 如果定义static const或者static constexpr，则编译器会在常量区为其分配地址（因为这是一种全局常量）



##### 内存管理相关

内存泄漏问题：
资源未释放，主要是手动管理的堆区内存没有释放。用智能指针（例如shared_ptr进行计数和自动释放），同时注意避免shared_ptr的循环引用问题。



**内存池托管**

内存池内存分配放在了应用层，当我们需要分配内存时，从内存池中取出空闲的内存块；需要释放内存时，将这块内存放回内存池。

内存池将避免了系统调用（）；同时可以避免内存碎片问题



* 内存池通常通过链表（可以用隐式链表）来管理可用内存块

* 可以重载new和delete操作符：取出空闲的内存块并构造对象

* 可以解耦内存分配和构造，内存池只负责分配内存不负责构造对象。

  

经典内存池的设计与实现（基于C/C++） - 楊 思瞻的文章 - 知乎
https://zhuanlan.zhihu.com/p/1932035881654551822



**new/delete重载**

* 重载operate new函数，修改内存分配规则，重载delete，修改内存回收规则
* placement new 即void* new(size_t size,void* p)一般不重载，它本身也不分配内存



c++ new操作符及重载 - 莫名的文章 - 知乎
https://zhuanlan.zhihu.com/p/1948868179460875734





##### 智能指针相关

控制块的引用计数是原子变量，增减使用原子操作，因此智能指针的拷贝、删除是线程安全的



**循环引用问题：**
两个类相互持有对方的智能指针，相互引用，则计数始终大于等于1，永远不会被释放
