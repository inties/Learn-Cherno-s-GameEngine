# 游戏引擎模型加载系统设计

本文档旨在阐述本游戏引擎中模型加载与渲染系统的核心设计思路，以便于团队成员理解、协作和后续扩展。

## 1. 核心设计思想

系统构建遵循三大核心思想：**数据驱动**、**分层解耦**和**资源复用**。

-   **数据驱动**: 渲染的不是对象，而是数据。模型文件被解析为纯粹的数据结构，渲染管线根据这些数据执行操作。
-   **分层解耦**: 严格分离数据、逻辑和渲染。模型加载、场景图管理和GPU渲染是独立模块，可以独立修改和替换。
-   **资源复用**: 内存和性能是关键。所有可复用的资源（几何体、材质、纹理）都应只加载一次，并在多个实例间共享。

## 2. 架构与关键类

本系统通过一系列分工明确的类协同工作，将模型文件高效地转化为屏幕上的像素。

### 2.1. 主要类的功能与关系

-   **`Model`**: 模型的顶层入口。它本身是一个轻量级对象，是整个模型资源的逻辑句柄，负责触发加载流程，并持有场景图的根节点（`Node`）。

-   **`Node`**: 场景图节点。`Node`是构成模型层级结构的基础，它以树状结构组织起来，完整地还原了模型文件（如FBX）中的父子关系。每个`Node`包含：
    -   自身的局部变换矩阵（`m_LocalTransform`）。
    -   一个子`Node`列表（`m_Children`）。
    -   一个该节点直接拥有的`Mesh`列表（`m_Meshes`）。

-   **`Mesh`**: 最基本的可渲染单元。它代表了一块拥有单一材质的几何体。`Mesh`的设计是性能优化的关键：
    -   它**不**包含独立的顶点/索引缓冲区。
    -   而是存储在一个共享大缓冲区中的**偏移量（Offset）**和**数量（Count）**。
    -   持有一个对`Material`资源的引用。

-   **`Material`**: 定义了物体的外观。它是连接几何体与着色器的桥梁，负责：
    -   持有一个对`Shader`（着色器）的引用。
    -   持有一组`Texture`（纹理）引用。
    -   存储其他`uniform`数据，如颜色、PBR参数（粗糙度、金属度等）。
    -   其`Bind()`方法负责在渲染时激活`Shader`并设置好所有渲染状态。

-   **资源库 (`MeshLibrary`, `MaterialLibrary`, `TextureLibrary`)**: 全局单例资源管理器。它们是实现资源复用的核心，负责缓存和管理`Mesh`、`Material`和`Texture`。当请求加载一个资源时，会先在库中查找，如果已存在则直接返回引用，否则才从文件加载并存入缓存。

-   **`ModelLoader`**: 静态工具类。它封装了所有与`Assimp`库交互的复杂逻辑，将`Model`类与具体的加载实现解耦。其职责包括：
    -   解析模型文件。
    -   递归处理节点，构建`Node`树。
    -   提取`Mesh`和`Material`数据。
    -   与资源库交互，实现资源的缓存与复用。

**关系图**:
```
ModelLoader --uses--> Assimp
      |
      +--creates/retrieves from--> MeshLibrary, MaterialLibrary, TextureLibrary
                                      ^
                                      | (stores)
                                      |
Model --owns--> Node (tree) --contains--> Mesh --uses--> Material --uses--> (Shader, Texture)
```

## 3. 设计亮点

1.  **极致的资源复用**: 不仅是纹理，连`Mesh`（几何体）和`Material`（材质）也被纳入了全局缓存。对于包含大量重复元素的复杂场景（如森林、城市建筑群），这种设计能极大节省内存和显存，并显著提升后续模型的加载速度。

2.  **共享缓冲区与偏移绘制**: 这是系统性能的关键。一个模型的所有几何数据被合并到单个（或少数几个）大的VBO/EBO中。`Mesh`仅通过存储偏移量和顶点数来引用自己的数据片段。渲染时，通过`glDrawElementsBaseVertex`等现代图形API调用，无需切换缓冲区即可绘制不同`Mesh`，极大降低了CPU到GPU的通信开销和状态切换成本。

3.  **高度解耦与可扩展性**:
    -   **渲染API无关性**: 由于渲染逻辑被封装在底层的`Material`、`Buffer`等类中，未来若要从OpenGL迁移到Vulkan或DirectX，上层的模型加载和场景图逻辑几乎无需改动。
    -   **易于功能扩展**: 当前架构为未来的功能扩展打下了坚实基础。例如，可以平滑地集成**骨骼动画**（在`Node`和`Mesh`中增加骨骼和权重数据）、实现**GPU实例化渲染**（为`Mesh`的绘制调用添加实例化数据），或开发一个**实时材质编辑器**（直接修改`Material`资源，所有引用该材质的模型都会立即更新）。

## 4. 总结

该模型加载系统通过场景图、资源库和共享缓冲区等设计，构建了一个权责清晰、性能高效、易于扩展的架构，为游戏引擎的渲染能力提供了稳固的基石。
