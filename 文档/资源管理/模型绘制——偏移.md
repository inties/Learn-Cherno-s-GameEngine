# 模型绘制——偏移方案

## 引言

在引擎的模型渲染系统中，为优化内存和性能，我们采用共享缓冲区设计：一个模型（Model）或全局资源管理器持有单一的VertexArray（VAO）、VertexBuffer（VBO）和IndexBuffer（EBO），所有子网格（Mesh）共享这些缓冲区。每个Mesh仅存储对VAO的引用、顶点/索引的偏移（offset）和长度（count），而非独立的缓冲区。这减少了GPU上传开销和对象数量，支持高效的子范围绘制（如使用glDrawElementsBaseVertex）。

此方案基于Assimp集成设计，解决了每个Mesh独立创建缓冲区的冗余问题。Mesh被视为“静态网格”，Model管理场景图（Node树），渲染时结合全局/局部变换和相机参数。

## 关键类设计

### Mesh（静态网格）
- **角色**：代表模型的最小可渲染单元，存储几何数据的子范围引用和材质。
- **关键成员**：
  - Ref<VertexArray> m_SharedVAO; // 引用共享VAO（从Model或全局获取）。
  - uint32_t m_VertexOffset; // 顶点缓冲区起始偏移。
  - uint32_t m_VertexCount; // 顶点数量。
  - uint32_t m_IndexOffset; // 索引缓冲区起始偏移。
  - uint32_t m_IndexCount; // 索引数量。
  - Ref<Material> m_Material; // 材质引用。
- **Draw方法**：不传入偏移（内部已存储），直接使用m_SharedVAO和偏移调用RenderCommand::DrawIndexed(m_SharedVAO, m_IndexOffset, m_IndexCount, m_VertexOffset)。
- **优势**：Mesh轻量，无需管理缓冲区创建/销毁。

### Node（场景图节点）
- **角色**：构建模型层级结构，每个节点持有局部变换（m_LocalTransform）和子Mesh/子Node列表。
- **Draw方法**：递归计算世界变换（worldTransform = parentTransform * m_LocalTransform），为每个Mesh调用Draw（传入worldTransform）。

### Model（模型入口）
- **角色**：持有根Node和全局变换（m_GlobalTransform），引用共享VAO（不存储，仅管理引用）。
- **关键成员**：
  - Ref<Node> m_RootNode;
  - glm::mat4 m_GlobalTransform = glm::mat4(1.0f); // 模型整体变换（位置、旋转、缩放）。
  - Ref<VertexArray> m_SharedVAO; // 共享VAO引用（可选，如果不全局管理）。
- **Create方法**：加载时收集所有顶点/索引数据，统一上传到共享VAO，并为每个Mesh设置偏移。
- **Draw方法**：应用m_GlobalTransform到根Node的Draw调用。
- **缓冲区管理**：VAO/VBO/EBO数据由Model或专用资源管理器（e.g., ModelBufferManager）持有，确保生命周期与Model一致。

### 全局缓冲区管理
- VAO、VBO、EBO不应由Model直接存储，而是移到专用类（如ModelBufferPool），以支持跨模型共享（e.g., 实例化渲染）。但初始实现可per-Model。

## 加载流程（ModelLoader）
1. **收集数据**：递归ProcessNode，提取所有aiMesh的顶点/索引到共享列表（allVertices, allIndices）。
2. **计算偏移**：为每个Mesh记录偏移（e.g., m_VertexOffset = currentVertexSize; currentVertexSize += vertices.size()）。
3. **统一上传**：创建共享VAO，上传allVertices到VBO、allIndices到EBO，设置布局。
4. **设置引用**：为每个Mesh设置m_SharedVAO引用和偏移。
5. **材质处理**：独立于缓冲区，使用MaterialLibrary缓存。

## 渲染流程（Renderer）
- **Submit方法**：不需传入偏移（Mesh内部有）。签名：static void Submit(const Ref<Mesh>& mesh, const glm::mat4& transform, Camera& camera);
  - 内部：material->Bind(); shader->SetMat4("u_Model", transform); shader->SetMat4("u_ViewProjection", camera.GetViewProjection()); mesh->m_SharedVAO->Bind(); RenderCommand::DrawIndexedWithOffset(...);
- **相机集成**：
  - **最佳方法**：在Submit中添加Camera参数，直接计算并设置ViewProjection矩阵。这避免全局状态（e.g., BeginScene设置的s_SceneData），更灵活（支持多相机场景，如分屏渲染）。
  - 替代：保留BeginScene(Camera&)设置全局ViewProjection，但Submit不需Camera（从s_SceneData获取）。添加参数更直接，减少状态依赖。
- **整体流程**：
  1. Model::Draw()：应用m_GlobalTransform，调用根Node::Draw。
  2. Node::Draw(parentTransform)：计算worldTransform，for each mesh: Renderer::Submit(mesh, worldTransform, currentCamera)。
  3. Renderer::Submit：设置uniforms，绑定VAO，使用Mesh偏移绘制。

## 优势和注意事项
- **优势**：内存高效（共享缓冲减少冗余）；性能好（少量绑定/上传）；灵活（易扩展到实例化/动态模型）。
- **注意事项**：
  - 偏移计算需精确，避免越界（使用uint32_t，检查总大小）。
  - 相机参数确保per-Submit设置，支持动态视图。
  - 测试：加载多Mesh模型，验证绘制无偏移错误。
  - 扩展：未来添加骨骼动画时，偏移需考虑动态更新。

此方案整合了共享偏移和相机参数，优化了模型绘制。