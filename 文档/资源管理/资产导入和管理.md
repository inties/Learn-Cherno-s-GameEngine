项目与资源（最小实现）需求与概要设计（修订版）

一、目标与范围
- 目标：以最小成本打通“项目路径管理 + Content 浏览/添加 + 从 Content 将模型拖入场景并渲染”的闭环。
- 范围内：
  - Project 管理器：维护项目根路径；支持浏览文件并将文件加入当前项目（仅记录/展示）。
  - 资源管理器：持有并复用场景中使用到的资源（模型、纹理），负责加载与缓存；提供最基本的获取接口。
  - EditorLayer+Panels：EditorLayer 持有并绘制各面板（包括 Content/Hierarchy/Viewport），处理拖拽事件（ImGui），并调用资源加载与场景放置。
- 明确不纳入本次最小实现（后续再做）：
  - 依赖管理、热重载、异步加载、错误回退、统计与调试、线程安全等高级能力。
  - ECS/组件/实体相关设计（本方案避免这些术语与实现）。

二、用户故事（最小闭环）
- US-1 作为用户，我可以在编辑器中设置项目根路径，让 Content 窗口显示该路径下的文件。
- US-2 作为用户，我可以在 Content 中通过“浏览并添加文件”操作，将一个模型文件加入项目（在工程记录里可见）。
- US-3 作为用户，我可以从 Content 将模型文件拖拽到 Hierarchy 或 Viewport，从而在场景中生成一个“场景对象”（包含模型与变换）并显示该模型。

三、功能需求
1) Project 管理器（ProjectManager）
- 维护“项目根路径”（单个字符串）。
- 提供接口：
  - SetProjectRoot(path)：设置项目根路径（支持 UI 选择路径）。
  - GetProjectRoot()：返回项目根路径。
  - AddFileByBrowse(path)：从文件选择器得到的绝对路径，将其规范化为相对项目根的路径并加入项目记录（Asset 列表）。
  - ListAssets()：返回已加入项目的资源条目（文件相对路径 + 粗粒类型）。
- 行为：
  - 仅做记录与展示，不做复杂导入；资产类型可基于扩展名简单判断（如 .obj/.fbx 为模型，.png/.jpg 为纹理）。

2) 资源管理器（ResourceManager）
- 作用：持有并复用场景中使用到的资源（模型、纹理）。
- 加载机制：
  - LoadModel(relativePath)：若缓存中存在则复用；否则调用现有模型加载链路创建（Model::Create -> ModelLoader）。
  - LoadTexture(relativePath)：同理使用 Texture 等现有能力（若存在）。
- 获取与释放：
  - GetModel(path)：返回已加载模型（若未加载可选择懒加载）。
  - GetTexture(path)：返回已加载纹理（若未加载可选择懒加载）。
- 备注：本阶段只考虑主线程串行加载与持有，简化线程/统计/回退逻辑。

3) Content 窗口（ContentPanel）
- 所属与职责：由 EditorLayer 持有并在其 OnImGuiRender 内绘制；负责基于项目根路径展示文件树，并发起拖拽。
- 展示：项目根路径下的文件树（过滤隐藏文件）。
- 基础操作：
  - 设置/更改项目根路径后刷新内容。
  - 浏览并添加文件：调用 ProjectManager.AddFileByBrowse，成功后将该文件出现在 Content 资源列表中（或以“已加入项目”的标识显示）。
- 拖拽：
  - 在 Content 项目上开始拖拽时，通过 ImGui 设置 DragDrop Payload，载荷为模型文件的相对路径（相对 projectRoot）。
  - EditorLayer 在 Hierarchy/Viewport 面板区域接收该 Payload，并触发放置逻辑（见“场景集成”）。

4) 场景集成（无 ECS 版）
- 场景对象定义：
  - SceneObject：{ name: string, transform: mat4 或 TRS, modelPath: string, modelRef: Ref<Model> }
- 场景容器与接口（可称 Scene / SceneManager，二选一，不引入实体/组件概念）：
  - AddModelInstance(relativePath, optionalTransform) -> SceneObject&：
    - 根据模型路径检查是否已经有该模型，有则复用，创建一个新的模型实例，而无需重新加载模型。
    - 调用 ResourceManager.LoadModel(relativePath) 获取/创建模型。
    - 新建 SceneObject，记录 relativePath 与返回的 modelRef，设置默认/传入的变换，加入内部列表。
  - GetModelObjects() -> const vector<SceneObject>&：供渲染层遍历。
  - RemoveObject(id/name)（可选，非本次必需）。
- 拖拽放置流程（EditorLayer 处理）：
  - 在 Hierarchy/Viewport 面板接收 DragDrop Payload（relativePath）。
  - 调用 Scene.AddModelInstance(relativePath, 默认变换[位置(0,0,0)、缩放(1,1,1)、旋转0])。
  - 触发 UI 刷新，用户能在 Viewport 中看到该对象(交给imgui处理)。

5) 渲染集成（改造 RendererLayer，去除硬编码渲染内容）
- 现状问题：RendererLayer 里硬编码了“立方体 + 指定模型”的渲染逻辑，未与“场景中的模型对象”打通。
- 目标：RendererLayer 渲染来源统一为“当前场景中的 SceneObject 列表”，遍历并绘制所有模型对象；保留立方体/调试渲染作为可选开关（不影响主流程）。
- 对 RendererLayer 的最小改动建议：
  1) 注入场景：提供 SetScene(Scene*)，在 EditorLayer::OnAttach/初始化阶段完成绑定。
  2) 遍历绘制：在 OnUpdate 内，替换“m_Model->Draw() 之类的硬编码调用”为：
     - 获取 scene->GetModelObjects()；对每个 obj：
       - obj.modelRef->SetGlobalTransform(obj.transform);
       - obj.modelRef->Draw();
  3) 调试开关：保留现有 m_UseDebugShader 流程；若开启，则对每个 obj 应用相同的调试渲染分支（或跳过，按当前实现策略）。
  4) 过渡期策略：
     - 立方体演示可保留（用于校验渲染管线），但不影响“场景对象”的渲染；
     - 原先硬编码加载的背包模型应移除到“示例数据”层：即通过 Content 拖拽加入场景，而非在 RendererLayer::SetupModel 中加载。
- 数据流：
  - Content 发起拖拽 -> EditorLayer 在目标面板接收 -> 调 Scene.AddModelInstance -> RendererLayer 从 Scene 拉取对象并渲染。

四、非功能需求（最小约束）
- 路径规范：统一以相对项目根路径作为资源键，需在 Add/Load 前做规范化（统一分隔符，消除重复"/\\"）。
- 单线程：所有操作主线程串行，避免并发问题。
- 错误处理：加载失败仅日志打印并在 UI 提示，功能不中断。

五、概要设计
1) 模块与依赖（文本描述）
- ProjectManager：记录 projectRoot，维护 AssetEntry 列表；对外提供 SetProjectRoot/AddFile/ListAssets。
- ResourceManager：维护 map<string, Ref<Model>> 与 map<string, Ref<Texture2D>>；对外提供 Load/Get 接口；内部使用现有 ModelLoader 与 Texture 能力。
- EditorLayer（持有并绘制面板）：
  - ContentPanel：基于 projectRoot 展示文件树；在文件项上发起拖拽（设置 ImGui Payload）。
  - HierarchyPanel/ViewportPanel：接收拖拽 Payload（relativePath），调用 Scene.AddModelInstance。
  - 与 RendererLayer 建立联系（传入 Scene 指针）。
- Scene（或 SceneManager）：按“场景集成（无 ECS 版）”存储 SceneObject 列表，暴露 Add/Get 接口。
- RendererLayer：在 OnUpdate 中遍历场景对象进行绘制，取消对具体模型资源的硬编码加载与绘制。

2) 关键数据结构（示意）
- AssetEntry：{ relativePath: string, type: enum {Model, Texture, Unknown} }
- SceneObject：{ name: string, transform: mat4 或 TRS, modelPath: string, modelRef: Ref<Model> }

3) 核心接口（示意）
- ProjectManager
  - SetProjectRoot(path)
  - GetProjectRoot() -> string
  - AddFileByBrowse(absPath) -> bool  // 规范化并加入 AssetEntry
  - ListAssets() -> vector<AssetEntry>
- ResourceManager
  - LoadModel(relativePath) -> Ref<Model>
  - GetModel(relativePath) -> Ref<Model>
  - LoadTexture(relativePath) -> Ref<Texture2D>
  - GetTexture(relativePath) -> Ref<Texture2D>
- Scene（或 SceneManager）
  - AddModelInstance(relativePath, transform=Identity) -> SceneObject&
  - GetModelObjects() -> const vector<SceneObject>&
- EditorLayer
  - SetScene(Scene*)
  - 处理 Content 拖拽起点；在 Hierarchy/Viewport 接收拖拽终点并调用 Scene/ResourceManager
- RendererLayer
  - SetScene(Scene*)
  - OnUpdate()：遍历 Scene.GetModelObjects() 并绘制

4) 典型流程
- 浏览并添加文件：
  1) 用户在 Content 点击“添加文件” -> 打开文件选择器（系统对话框）。
  2) 选择 absPath -> 调用 ProjectManager.AddFileByBrowse(absPath)。
  3) 规范化为 relativePath（相对 projectRoot），加入 AssetEntry 列表。
  4) ContentPanel 刷新列表，能看到新文件。
- 从 Content 拖拽模型到场景：
  1) 用户从 Content 拖拽某模型文件（.obj/.fbx 等）到 Hierarchy/Viewport。
  2) EditorLayer 在目标面板接收 Payload(relativePath)。
  3) 调用 Scene.AddModelInstance(relativePath)：内部通过 ResourceManager.LoadModel(relativePath) 获得/复用模型，并记录为 SceneObject。
  4) RendererLayer 在 OnUpdate 中遍历 SceneObject 并绘制；用户在 Viewport 能看到模型。
  5) 重复拖拽同一路径，二次加载命中缓存，仅新增一个 SceneObject 以实现多实例。

