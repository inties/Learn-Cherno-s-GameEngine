资源管理需求分析（基于当前实现）

一、现状概述（代码事实）
- 模型加载入口：Model::Create(path) -> ModelLoader::Load(path, model)。
- Assimp 导入配置：Triangulate、FlipUVs、GenSmoothNormals、SplitLargeMeshes、OptimizeMeshes，用于得到可渲染的三角网格并优化拓扑。
- 网格数据组织：递归遍历场景树，收集所有 Mesh 的顶点与索引，合并到一个大数组；为每个 Mesh 记录 vertex/index 的偏移与长度。
- 缓冲与渲染：一次性创建共享 VAO（含单个 VBO/IBO），每个 Mesh 以偏移+长度引用共享缓冲绘制，顶点布局固定为 Position/Normal/TexCoord/Tangent/Bitangent。
- 材质与纹理：按 Mesh 的 materialIndex 生成或复用材质（以“模型路径::mat::<index>”键在材质库缓存），默认着色器尝试“DefaultPBR”，失败时回落加载 assets/shaders/default.glsl。遍历 aiMaterial 的纹理，根据类型映射到统一的 uniform 名（Albedo/Specular/Normal 等），纹理通过纹理库按文件路径加载。若缺失/异常则回落到默认材质或跳过。
- 场景图结构：构建 Node 树，节点含本地变换、Mesh 列表与子节点；Model 持有根节点与全局变换，Draw 从根节点递归渲染。

二、总体目标（需求）
- 统一资源寻址：统一路径规范与资源根目录，规避重复加载与路径不一致问题。
- 资源缓存与生命周期：对模型/材质/纹理/着色器做集中缓存与复用，控制内存占用，避免重复创建。
- 编辑器联动：Content 窗口扫描资源目录、展示基础信息；支持搜索/重命名/删除；资源拖拽到 Hierarchy/Viewport 生成场景对象。
- 依赖管理：模型->网格/材质->纹理->着色器的依赖可追踪，便于显示、热更与统计。
- 热重载：资源文件变更后可刷新到引擎与编辑器（至少提供手动刷新）
- 异步加载：加载大资源时不阻塞主线程，提供占位资源策略，加载完成后无缝替换。
- 错误回退：缺失/损坏资源使用默认占位（灰白材质、默认立方体/平面、默认 shader），保证引擎稳定。
- 统计与调试：提供查询接口（驻留内存数量/大小、引用计数、最近使用时间）与日志。
- 线程安全：异步和主线程访问资源库时需基本同步保护。

三、可选方案（均可行，落地成本低）
1) 资源标识/寻址方案
- 方案A：相对路径（推荐起步）
  - 规则：以统一 Assets 根为相对路径关键字（如 "assets/..."），所有库加载前执行路径规范化（去重分隔符、大小写策略）。
  - 优点：与现状最贴近，改动小；编辑器显示直观。
  - 要点：为各 Library 增加 PathNormalize 与 Exists/Get 统一入口；ModelLoader/TextureLibrary/ShaderLibrary 统一走相对路径键。
- 方案B：路径 + 轻量 GUID 映射
  - 在工程根保存 assets_index.json，记录 {guid: path, type}，库对外接受 guid，内部映射到路径。
  - 优点：后续重命名/移动不破坏引用；编辑器可显示 GUID 与路径。
  - 成本：维护一份 JSON，编辑器保存时更新即可。
- 方案C：.meta 元数据
  - 每个资源旁边生成 .meta（含 guid、导入选项），扫描目录时读取。
  - 优点：与常见引擎流程接近；支持更多导入参数。
  - 成本：实现略高于B，但仍可先做最小字段。

2) 缓存与生命周期
- 方案A：现有单例库 + shared_ptr/Ref（推荐起步）
  - Get/LoadIfAbsent：存在直接返回，不存在则加载并缓存；释放靠智能指针计数自然回收。
  - 增加统一的 Remove/Reload 接口与统计接口。
- 方案B：引用计数 + LRU 清理
  - 增加最近使用队列与容量阈值，编辑器/运行时可触发 Trim() 按需释放不常用资源。
- 方案C：场景级持有 + 全局弱引用
  - 场景持强引用，库为弱引用查询，切换场景时快速卸载。

3) 热重载
- 方案A：手动刷新按钮（推荐起步）
  - 点击后对选中资源或全量资源比对时间戳，变化则调用 Reload()。
- 方案B：时间戳轮询
  - 编辑器定时（如1s）扫描变化，触发 Reload。
- 方案C：文件系统监听
  - Windows 下可用 ReadDirectoryChangesW；实现稍复杂但体验最佳。

4) 异步加载
- 方案A：std::async + 占位资源（推荐起步）
  - 立即返回默认材质/默认网格，后台加载完成后替换，并在下一帧或信号量安全切换。
- 方案B：简易线程池
  - 固定N线程执行资源任务队列；统一回调到主线程完成 GPU 上传与对象替换。
- 方案C：分帧加载
  - 将导入、CPU 处理、GPU 上传分阶段跨帧执行；实现复杂度略高。

5) 模型数据上传与 Mesh 组织
- 方案A：延续“共享VAO+偏移”（现状，推荐）
  - 保持一次上传，Mesh 以偏移绘制，减少缓冲切换，适合静态模型。
- 方案B：每 Mesh 独立缓冲
  - 调试简单，便于按需释放与流式加载；小幅增加切换开销。
- 方案C：静态大缓冲 + 合批器
  - 引入统一合批管理；实现成本较高，可后续演进。

6) 材质与纹理加载策略
- 方案A：按需加载 + 默认材质回退（推荐起步）
  - 加载模型时仅加载引用纹理；缺失使用默认。
- 方案B：预扫描材质并预加载纹理
  - 减少首次渲染抖动，适合关卡加载阶段。
- 方案C：延迟加载纹理
  - 首次绑定时才真正从磁盘读取，需在材质绑定处做判定。

7) 编辑器与场景集成
- 方案A：拖拽路径到 Hierarchy/Viewport（推荐起步）
  - 通过 SceneManager 调用 Model::Create，相对路径写入组件，场景保存时保留引用。
- 方案B：拖拽 GUID
  - 显示资源 GUID，落地后映射到路径加载；便于资源重命名。
- 方案C：Prefab 化
  - 模型+初始材质/变换打包为 Prefab，拖拽实例化；实现稍后成熟再做。

四、推荐组合（低成本、可快速落地）
- 寻址：方案A 相对路径（统一 Assets 根 + 路径规范化）。
- 缓存：方案A 单例资源库 + Get/LoadIfAbsent + 统计接口。
- 热重载：方案A 手动刷新，补充方案B 时间戳轮询可开关。
- 异步加载：方案A std::async + 占位资源，GPU 上传仍在主线程完成。
- 模型组织：沿用共享VAO+偏移（保持现有性能优势）。
- 材质纹理：按需加载 + 默认材质回退；在编辑器 Content 面板可预览依赖链。
- 编辑器：Content 扫描 assets/ 目录，支持搜索/重命名/删除；拖拽相对路径生成场景对象。

五、最小实现清单（建议迭代）
1) 路径与缓存
- 在 Shader/Texture/Material/Model 四个库统一增加：PathNormalize、Exists、Get、Load、Reload、Remove、Stats。
- 统一使用相对路径作为缓存键；Model 材质键从“模型路径::mat::<index>”过渡为“相对路径::mat::<index>”。

2) 编辑器与 Content 面板
- 扫描 assets/ 目录生成资源树，支持筛选/搜索；右键菜单：重命名、删除、手动刷新。
- 拖拽到 Hierarchy/Viewport：创建实体并附加 Model 组件（记录相对路径）。

3) 热重载
- Content 面板“刷新”按钮：比对时间戳，调用相应库的 Reload(path)。

4) 异步
- 提供 AsyncLoadModel(path) 与占位 Model；加载完成后在主线程替换并触发一次渲染刷新。

5) 回退与统计
- 提供默认材质/默认网格/默认 shader；库侧 Stats 输出（数量、内存估计、最近访问时间）。

附：后续可选增强
- 文件系统监听替代轮询；
- 纹理压缩与 MipMap 预计算；
- 简易资源导入器（生成 .meta，记录导入选项与 GUID）。


概要设计：


详细设计：